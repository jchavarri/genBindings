// @flow
const { spawnSync } = require("child_process");
const path = require("path");
const fs = require("fs");
const { fromJson } = require("./GenBindings.bs");

const isGenBindingsComment = commentValue =>
  commentValue.includes("@genBindings");
const getValue = comment => comment.value;
const getLoc = declaration => declaration.loc;

const camelize = str => {
  return str
    .replace(/(?:^\w|[A-Z]|\b\w)/g, (letter /*, index */) => {
      return letter.toUpperCase();
    })
    .replace(/\s+/g, "");
};

const getFlowTypes = (fileName, line, column) => {
  const flowPath = "node_modules/.bin/flow"; // TODO: add config
  if (!fs.existsSync(flowPath)) {
    console.warn(`genBindings: Couldn't find flow at path ${flowPath}.`);
    return;
  }
  return spawnSync(
    flowPath,
    [
      "type-at-pos",
      "--expand-json-output",
      fileName,
      String(line),
      String(column)
    ],
    { encoding: "utf8" }
  ).stdout;
};

/*::
type Node = {|
  type: string,
  leadingComments?: Comment[],
  innerComments?: Comment[],
  trailingComments?: Comment[],
  start: number,
  end: number,
  loc: SourceLocation
|};
type SourceLocation = {|
  start: {|
    line: number,
    column: number
  |},
  end: {|
    line: number,
    column: number
  |}
|};
type Comment = {|
  type: "CommentBlock" | "CommentLine",
  value: string,
  start: number,
  end: number,
  loc: SourceLocation
|};
type Identifier = {|
  ...Node,
  type: "Identifier",
  name: string,
  typeAnnotation?: Object // TypeAnnotation {...Node, type: "TypeAnnotation", typeAnnotation: FlowTypeAnnotation}
|};
type DeclareTypeAlias = {|
  ...Node,
  type: "DeclareTypeAlias",
  id: Identifier
  // typeParameters: //TypeParameterDeclaration,
  // right: FlowTypeAnnotation
|};
type ExportNamedDeclaration = {|
  ...Node,
  type: "ExportNamedDeclaration",
  declaration: Declaration
  // specifiers: ExportSpecifier[]
  //source: StringLiteral | null
|};
type VariableDeclaration = {|
  ...Node,
  type: "VariableDeclaration",
  declarations: VariableDeclarator[],
  kind: "var" | "let" | "const"
|};
type VariableDeclarator = {|
  ...Node,
  type: "VariableDeclarator",
  id: LVal;
  // init: Expression;
|};
type LVal = Identifier; // | MemberExpression | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern | TSParameterProperty;
type Declaration = VariableDeclaration | DeclareTypeAlias; // Missing a lot: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/65fcea8f3e9affa54ebdd45bfaee98ea0c85f939/types/babel-types/index.d.ts#L1256

type State = {| cache: string, typeAliases: [string] |};
*/

module.exports = function(/*{ types: t }: {types: Object} */) {
  return {
    pre(/*_state: State */) {
      this.cache = "";
      this.typeAliases = [];
    },
    post(/*state: State */) {
      if (typeof this.opts.output === "function") {
        this.opts.output(this.cache);
      } else {
        const absPath = this.file.opts.filename;
        const extension = path.extname(absPath);
        const file = path.basename(absPath, extension);
        const reasonPath = path.join(
          path.dirname(absPath),
          camelize(file) + "Bindings.re"
        );
        if (this.cache.length > 0) {
          const output =
            "/* THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.*/\n\n" +
            this.cache;
          fs.writeFileSync(reasonPath, output, "utf8");
        } else {
          try {
            fs.unlinkSync(reasonPath);
          } catch (e) {
            console.warn(`Unable to remove file at ${reasonPath}`);
          }
        }
      }
    },
    visitor: {
      TypeAlias(
        { node, hub } /*: {| node: DeclareTypeAlias, hub: Object |} */
      ) /*state : State */
      {
        if (
          node.leadingComments &&
          node.leadingComments.map(getValue).some(isGenBindingsComment)
        ) {
          const id = node.id;
          const loc = getLoc(id);
          const flowOutput = getFlowTypes(
            hub.file.opts.filename,
            loc.start.line,
            loc.start.column + 1
          );
          if (!flowOutput) {
            console.error(
              "genBindings: Could not read output from Flow binary. Is `flow-bin` installed locally?"
            );
            return;
          }
          const expandedType = JSON.parse(flowOutput.toString()).expanded_type;
          if (!expandedType) {
            console.error(
              "genBindings: Could not read output from Flow binary. Is `flow-bin` installed locally?"
            );
            return;
          }
          const binding = fromJson(
            expandedType,
            hub.file.opts.filename,
            loc.start.line,
            id.name
          );
          this.cache = this.cache + binding;
        }
      },
      ExportNamedDeclaration(
        { node, hub } /*: {| node: ExportNamedDeclaration, hub: Object |} */
      ) /*state: State */
      {
        if (
          node.leadingComments &&
          node.leadingComments.map(getValue).some(isGenBindingsComment)
        ) {
          const declaration = node.declaration;
          if (declaration.type === "VariableDeclaration") {
            const declarations = declaration.declarations;
            declarations.forEach(dec => {
              const loc = getLoc(dec);

              const flowOutput = getFlowTypes(
                hub.file.opts.filename,
                loc.start.line,
                loc.start.column + 1
              );
              if (!flowOutput) {
                console.error(
                  "genBindings: Could not read output from Flow binary. Is `flow-bin` installed locally?"
                );
                return;
              }
              const expandedType = JSON.parse(flowOutput.toString())
                .expanded_type;
              if (!expandedType) {
                return;
              }
              const declarationName = dec.id.name;

              const binding = fromJson(
                expandedType,
                hub.file.opts.filename,
                loc.start.line,
                declarationName
              );
              if (binding.length > 0) {
                this.cache = this.cache + binding;
              }
            });
          }
        }
      }
    }
  };
};
