const { spawnSync } = require("child_process");
const path = require("path");
const fs = require("fs");

const isDrillTypeComment = commentValue =>
  commentValue.includes("@genBindings");
const getValue = comment => comment.value;
const getLoc = declaration => declaration.loc;
const getKind = expandedType => expandedType.kind;

const checkAny = arrayTypes => arrayTypes.some(t => t.kind === "Any");
const typeFromFlowKind = kind => {
  if (kind === "Num") {
    return "float";
  } else if (kind === "Str") {
    return "string";
  }
};

const camelize = str => {
  return str
    .replace(/(?:^\w|[A-Z]|\b\w)/g, (letter, index) => {
      return letter.toUpperCase();
    })
    .replace(/\s+/g, "");
};

module.exports = function({ types: t }) {
  return {
    pre(state) {
      this.cache = "";
    },
    post(state) {
      if (typeof this.opts.output === "function") {
        this.opts.output(this.cache);
      } else {
        const absPath = this.file.opts.filename;
        const extension = path.extname(absPath);
        const file = path.basename(absPath, extension);
        const reasonPath = path.join(
          path.dirname(absPath),
          camelize(file) + "Bindings.re"
        );
        if (this.cache.length > 0) {
          const output =
            "/* THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.*/\n\n" +
            this.cache;
          fs.writeFileSync(reasonPath, output, "utf8");
        } else {
          try {
            fs.unlinkSync(reasonPath);
          } catch (e) {}
        }
      }
    },
    visitor: {
      ExportNamedDeclaration({ node, hub }, state) {
        if (
          node.leadingComments &&
          node.leadingComments.map(getValue).some(isDrillTypeComment)
        ) {
          const declarations = node.declaration.declarations;
          declarations.forEach(dec => {
            const loc = getLoc(dec);

            const flowPath = "node_modules/.bin/flow"; // TODO: add config
            if (!fs.existsSync(flowPath)) {
              console.warn(
                `genBindings: Couldn\'t find flow at path ${flowPath}.`
              );
              return;
            }

            const flowOutput = spawnSync(
              "node_modules/.bin/flow",
              [
                "type-at-pos",
                "--expand-json-output",
                hub.file.opts.filename,
                loc.start.line,
                loc.start.column + 1
              ],
              { encoding: "utf8" }
            );
            if (!flowOutput.stdout) {
              console.warn(`genBindings: Could not read output from Flow.`);
              return;
            }
            const expandedType = JSON.parse(flowOutput.stdout).expanded_type;
            if (!expandedType) {
              return;
            }
            const declarationName = dec.id.name;
            const reasonDecName = declarationName.toLowerCase();
            if (expandedType.kind === "Str") {
              const binding =
                '[@bs.module "./' +
                path.basename(hub.file.opts.filename) +
                '"]\n' +
                "external " +
                reasonDecName +
                ' : string = "' +
                (reasonDecName !== declarationName ? declarationName : "") +
                '";\n\n';
              this.cache = this.cache + binding;
            } else if (expandedType.kind === "Fun") {
              const hasAny = checkAny(
                expandedType.paramTypes.concat([expandedType.returnType])
              );
              if (hasAny) {
                this.cache =
                  this.cache +
                  `/* Exported function "${reasonDecName}" has parameter types or returned type "any" and can't be exported. */\n\n`;
                return;
              } else {
                const binding =
                  '[@bs.module "./' +
                  path.basename(hub.file.opts.filename) +
                  '"]\n' +
                  "external " +
                  reasonDecName +
                  ": (" +
                  expandedType.paramTypes
                    .map(getKind)
                    .map(typeFromFlowKind)
                    .join(", ") +
                  ") => " +
                  typeFromFlowKind(expandedType.returnType.kind) +
                  ' = "' +
                  (reasonDecName !== declarationName ? declarationName : "") +
                  '";\n\n';
                this.cache = this.cache + binding;
              }
            }
          });
        }
      }
    }
  };
};
