const { spawnSync } = require("child_process");
const path = require("path");
const fs = require("fs");
const { decode } = require("./DecodeFlowJson.bs");

const isGenBindingsComment = commentValue =>
  commentValue.includes("@genBindings");
const getValue = comment => comment.value;
const getLoc = declaration => declaration.loc;
const getKind = expandedType => expandedType.kind;

const checkAny = arrayTypes => arrayTypes.some(t => t.kind === "Any");
const typeFromFlowKind = kind => {
  if (kind === "Num") {
    return "float";
  } else if (kind === "Str") {
    return "string";
  }
};
const typeFromProp = (prop /* : {kind, type, polarity, optional} */) => {
  const type = typeFromFlowKind(prop.type.kind);
  return prop.optional ? `optional(${type})` : type;
};

const camelize = str => {
  return str
    .replace(/(?:^\w|[A-Z]|\b\w)/g, (letter, index) => {
      return letter.toUpperCase();
    })
    .replace(/\s+/g, "");
};

const getFlowTypes = (fileName, line, column) => {
  const flowPath = "node_modules/.bin/flow"; // TODO: add config
  if (!fs.existsSync(flowPath)) {
    console.warn(`genBindings: Couldn\'t find flow at path ${flowPath}.`);
    return;
  }
  return spawnSync(
    flowPath,
    ["type-at-pos", "--expand-json-output", fileName, line, column],
    { encoding: "utf8" }
  ).stdout;
};

const objectFields = props => {
  return props
    .map(p => {
      if (p.kind === "NamedProp") {
        /* y: float, */
        return `${p.prop.name}: ${typeFromProp(p.prop.prop)}`;
      } else if (p.kind === "IndexProp") {
        /* ['y']: float, */
      } else {
        /* TODO: What else is there? */
      }
    })
    .filter(p => Boolean(p))
    .join(", ");
};

const external = (path, name, rest) => {
  return `[@bs.module "./${path}"] external ${name}${rest};\n`;
};

module.exports = function({ types: t }) {
  return {
    pre(state) {
      this.cache = "";
      this.typeAliases = [];
    },
    post(state) {
      if (typeof this.opts.output === "function") {
        this.opts.output(this.cache);
      } else {
        const absPath = this.file.opts.filename;
        const extension = path.extname(absPath);
        const file = path.basename(absPath, extension);
        const reasonPath = path.join(
          path.dirname(absPath),
          camelize(file) + "Bindings.re"
        );
        if (this.cache.length > 0) {
          const output =
            "/* THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.*/\n\n" +
            this.cache;
          fs.writeFileSync(reasonPath, output, "utf8");
        } else {
          try {
            fs.unlinkSync(reasonPath);
          } catch (e) {}
        }
      }
    },
    visitor: {
      TypeAlias({ node, hub }, state) {
        if (
          node.leadingComments &&
          node.leadingComments.map(getValue).some(isGenBindingsComment)
        ) {
          const id = node.id;
          const loc = getLoc(id);
          const flowOutput = getFlowTypes(
            hub.file.opts.filename,
            loc.start.line,
            loc.start.column + 1
          );
          const expandedType = JSON.parse(flowOutput).expanded_type;
          if (!expandedType) {
            return;
          }
          if (expandedType.kind === "TypeAlias") {
            if (!expandedType.exact) {
              // TODO: Add notice on output code
            }
            const recordFields = objectFields(expandedType.body.props);
            const binding = `type ${id.name} = { ${recordFields} };\n\n`;
            this.cache = this.cache + binding;
            this.typeAliases[id.name] = expandedType; //TODO: Figure out scope hoisting
          }
        }
      },
      ExportNamedDeclaration({ node, hub }, state) {
        if (
          node.leadingComments &&
          node.leadingComments.map(getValue).some(isGenBindingsComment)
        ) {
          const declarations = node.declaration.declarations;
          declarations.forEach(dec => {
            const loc = getLoc(dec);

            const flowOutput = getFlowTypes(
              hub.file.opts.filename,
              loc.start.line,
              loc.start.column + 1
            );
            if (!flowOutput) {
              console.warn(`genBindings: Could not read output from Flow.`);
              return;
            }
            const expandedType = JSON.parse(flowOutput).expanded_type;
            if (!expandedType) {
              return;
            }
            const declarationName = dec.id.name;
            const reasonDecName = declarationName.toLowerCase();

            if (expandedType.kind === "Str") {
              const binding =
                external(
                  path.basename(hub.file.opts.filename),
                  reasonDecName,
                  `: string = "${
                    reasonDecName !== declarationName ? declarationName : ""
                  }"`
                ) + "\n";
              this.cache = this.cache + binding;
            } else if (expandedType.kind === "Obj") {
              const recordFields = objectFields(expandedType.props);
              const binding =
                external(
                  path.basename(hub.file.opts.filename),
                  reasonDecName,
                  `: Js.t({. ${recordFields} }) = ""`
                ) + "\n";
              this.cache = this.cache + binding;
            } else if (expandedType.kind === "Generic") {
              const aliasedType = this.typeAliases[expandedType.type.name];
              // TODO: Add missing aliasedType handling
              if (!aliasedType) {
                throw Error("Missing alias type");
              }
              const binding = external(
                path.basename(hub.file.opts.filename),
                reasonDecName,
                ': Js.t(\'a) = ""'
              );
              const converterFromType = aliasedType.body.props
                .map(p => {
                  if (p.kind === "NamedProp") {
                    /* y: float, */
                    return `${p.prop.name}: ${reasonDecName}##${p.prop.name}`;
                  } else if (p.kind === "IndexProp") {
                    /* ['y']: float, */
                  } else {
                    /* TODO: What else is there? */
                  }
                })
                .filter(p => Boolean(p))
                .join(", ");
              const converter = `let ${reasonDecName} = {${converterFromType}};`;
              this.cache = this.cache + binding + converter;
            } else if (expandedType.kind === "Fun") {
              const hasAny = checkAny(
                expandedType.paramTypes.concat([expandedType.returnType])
              );
              if (hasAny) {
                this.cache =
                  this.cache +
                  `/* Exported function "${reasonDecName}" has parameter types or returned type "any" and can't be exported. */\n\n`;
                return;
              } else {
                const binding =
                  external(
                    path.basename(hub.file.opts.filename),
                    reasonDecName,
                    ": (" +
                      expandedType.paramTypes
                        .map(getKind)
                        .map(typeFromFlowKind)
                        .join(", ") +
                      ") => " +
                      typeFromFlowKind(expandedType.returnType.kind) +
                      ' = "' +
                      (reasonDecName !== declarationName
                        ? declarationName
                        : "") +
                      '"'
                  ) + "\n";
                this.cache = this.cache + binding;
              }
            }
          });
        }
      }
    }
  };
};
