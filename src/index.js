// @flow
const { spawnSync } = require("child_process");
const path = require("path");
const fs = require("fs");
const { fromJson } = require("./GenBindings.bs");

const isGenBindingsComment = commentValue =>
  commentValue.includes("@genBindings");
const getValue = comment => comment.value;
const getLoc = declaration => declaration.loc;

const typeFromFlowKind = kind => {
  if (kind === "Num") {
    return "float";
  } else if (kind === "Str") {
    return "string";
  }
};
const typeFromProp = (prop /* {kind, type, polarity, optional} */) => {
  const type = typeFromFlowKind(prop.type.kind);
  return prop.optional ? `option(${type})` : type;
};

const camelize = str => {
  return str
    .replace(/(?:^\w|[A-Z]|\b\w)/g, (letter, index) => {
      return letter.toUpperCase();
    })
    .replace(/\s+/g, "");
};

const getFlowTypes = (fileName, line, column) => {
  const flowPath = "node_modules/.bin/flow"; // TODO: add config
  if (!fs.existsSync(flowPath)) {
    console.warn(`genBindings: Couldn\'t find flow at path ${flowPath}.`);
    return;
  }
  return spawnSync(
    flowPath,
    [
      "type-at-pos",
      "--expand-json-output",
      fileName,
      String(line),
      String(column)
    ],
    { encoding: "utf8" }
  ).stdout;
};

const objectFields = props => {
  return props
    .map(p => {
      if (p.kind === "NamedProp") {
        /* y: float, */
        return `${p.prop.name}: ${String(typeFromProp(p.prop.prop))}`;
      } else if (p.kind === "IndexProp") {
        /* ['y']: float, */
      } else {
        /* TODO: What else is there? */
      }
    })
    .filter(p => Boolean(p))
    .join(", ");
};

const external = (path, name, rest) => {
  return `[@bs.module "./${path}"] external ${name}${rest};\n`;
};

/*::
type Node = {|
  type: string,
  leadingComments?: Comment[],
  innerComments?: Comment[],
  trailingComments?: Comment[],
  start: number,
  end: number,
  loc: SourceLocation
|};
type SourceLocation = {|
  start: {|
    line: number,
    column: number
  |},
  end: {|
    line: number,
    column: number
  |}
|};
type Comment = {|
  type: "CommentBlock" | "CommentLine",
  value: string,
  start: number,
  end: number,
  loc: SourceLocation
|};
type Identifier = {|
  ...Node,
  type: "Identifier",
  name: string,
  typeAnnotation?: Object // TypeAnnotation {...Node, type: "TypeAnnotation", typeAnnotation: FlowTypeAnnotation}
|};
type DeclareTypeAlias = {|
  ...Node,
  type: "DeclareTypeAlias",
  id: Identifier
  // typeParameters: //TypeParameterDeclaration,
  // right: FlowTypeAnnotation
|};
type ExportNamedDeclaration = {|
  ...Node,
  type: "ExportNamedDeclaration",
  declaration: Declaration
  // specifiers: ExportSpecifier[]
  //source: StringLiteral | null
|};
type VariableDeclaration = {|
  ...Node,
  type: "VariableDeclaration",
  declarations: VariableDeclarator[],
  kind: "var" | "let" | "const"
|};
type VariableDeclarator = {|
  ...Node,
  type: "VariableDeclarator",
  id: LVal;
  // init: Expression;
|};
type LVal = Identifier; // | MemberExpression | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern | TSParameterProperty;
type Declaration = VariableDeclaration | DeclareTypeAlias; // Missing a lot: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/65fcea8f3e9affa54ebdd45bfaee98ea0c85f939/types/babel-types/index.d.ts#L1256

type State = {| cache: string, typeAliases: [string] |};
*/

module.exports = function({ types: t } /*: {types: Object} */) {
  return {
    pre(state /*: State */) {
      this.cache = "";
      this.typeAliases = [];
    },
    post(state /*: State */) {
      if (typeof this.opts.output === "function") {
        this.opts.output(this.cache);
      } else {
        const absPath = this.file.opts.filename;
        const extension = path.extname(absPath);
        const file = path.basename(absPath, extension);
        const reasonPath = path.join(
          path.dirname(absPath),
          camelize(file) + "Bindings.re"
        );
        if (this.cache.length > 0) {
          const output =
            "/* THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.*/\n\n" +
            this.cache;
          fs.writeFileSync(reasonPath, output, "utf8");
        } else {
          try {
            fs.unlinkSync(reasonPath);
          } catch (e) {}
        }
      }
    },
    visitor: {
      TypeAlias(
        { node, hub } /*: {| node: DeclareTypeAlias, hub: Object |} */,
        state /*: State */
      ) {
        if (
          node.leadingComments &&
          node.leadingComments.map(getValue).some(isGenBindingsComment)
        ) {
          const id = node.id;
          const loc = getLoc(id);
          const flowOutput = getFlowTypes(
            hub.file.opts.filename,
            loc.start.line,
            loc.start.column + 1
          );
          if (!flowOutput) {
            console.error(
              "genBindings: Could not read output from Flow binary. Is `flow-bin` installed locally?"
            );
            return;
          }
          const expandedType = JSON.parse(flowOutput.toString()).expanded_type;
          if (!expandedType) {
            return;
          }
          const binding = fromJson(
            expandedType,
            path.basename(hub.file.opts.filename),
            id.name
          );
          this.cache = this.cache + binding;
        }
      },
      ExportNamedDeclaration(
        { node, hub } /*: {| node: ExportNamedDeclaration, hub: Object |} */,
        state /*: State */
      ) {
        if (
          node.leadingComments &&
          node.leadingComments.map(getValue).some(isGenBindingsComment)
        ) {
          const declaration = node.declaration;
          if (declaration.type === "VariableDeclaration") {
            const declarations = declaration.declarations;
            declarations.forEach(dec => {
              const loc = getLoc(dec);

              const flowOutput = getFlowTypes(
                hub.file.opts.filename,
                loc.start.line,
                loc.start.column + 1
              );
              if (!flowOutput) {
                console.error(
                  "genBindings: Could not read output from Flow binary. Is `flow-bin` installed locally?"
                );
                return;
              }
              const expandedType = JSON.parse(flowOutput.toString())
                .expanded_type;
              if (!expandedType) {
                return;
              }
              const declarationName = dec.id.name;
              const reasonDecName = declarationName.toLowerCase();

              const binding = fromJson(
                expandedType,
                path.basename(hub.file.opts.filename),
                declarationName
              );
              if (binding.length > 0) {
                this.cache = this.cache + binding;
              } else if (expandedType.kind === "Generic") {
                const aliasedType = this.typeAliases[expandedType.type.name];
                // TODO: Add missing aliasedType handling
                if (!aliasedType) {
                  throw Error("Missing alias type");
                }
                const binding = external(
                  path.basename(hub.file.opts.filename),
                  reasonDecName,
                  ': Js.t(\'a) = ""'
                );
                const converterFromType = aliasedType.body.props
                  .map(p => {
                    if (p.kind === "NamedProp") {
                      /* y: float, */
                      return `${p.prop.name}: ${reasonDecName}##${p.prop.name}`;
                    } else if (p.kind === "IndexProp") {
                      /* ['y']: float, */
                    } else {
                      /* TODO: What else is there? */
                    }
                  })
                  .filter(p => Boolean(p))
                  .join(", ");
                const converter = `let ${reasonDecName} = {${converterFromType}};`;
                this.cache = this.cache + binding + converter;
              }
            });
          }
        }
      }
    }
  };
};
